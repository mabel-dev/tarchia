# generated by fastapi-codegen:
#   filename:  ./definitions/rest-catalog-open-api.yaml
#   timestamp: 2024-05-08T23:24:10+00:00

from __future__ import annotations

from dataclasses import dataclass
from dataclasses import field
from datetime import date
from enum import Enum
from typing import Any
from typing import Dict
from typing import List
from typing import Optional
from typing import Union
from uuid import UUID


class ErrorModel:
    message: str = field(metadata={"description": "Human-readable error message"})
    type: str = field(
        metadata={
            "description": "Internal type definition of the error",
            "example": "NoSuchNamespaceException",
        }
    )
    code: conint(ge=400, le=600) = field(
        metadata={"description": "HTTP response code", "example": 404}
    )
    stack: Optional[List[str]] = None

    def __post_init__(self):
        if not self.message:
            raise ValueError("message is a required field")
        if not self.type:
            raise ValueError("type is a required field")
        if self.code is None:
            raise ValueError("code is a required field")


@dataclass
class CatalogConfig:
    overrides: Dict[str, str] = field(
        metadata={
            "description": "Properties that should be used to override client configuration; applied after defaults and client configuration."
        }
    )
    defaults: Dict[str, str] = field(
        metadata={
            "description": "Properties that should be used as default configuration; applied before client configuration."
        }
    )

    def __post_init__(self):
        if not self.overrides:
            raise ValueError("overrides is a required field")
        if not self.defaults:
            raise ValueError("defaults is a required field")


@dataclass
class UpdateNamespacePropertiesRequest:
    removals: Optional[List[str]] = field(
        default=None, metadata={"example": ["department", "access_group"], "unique_items": True}
    )
    updates: Optional[Dict[str, str]] = field(
        default=None, metadata={"example": {"owner": "Hank Bendickson"}}
    )


@dataclass
class Namespace:
    __root__: List[str] = field(
        metadata={
            "description": "Reference to one or more levels of a namespace",
            "example": ["accounting", "tax"],
        }
    )

    def __post_init__(self):
        if not self.__root__:
            raise ValueError("__root__ is a required field")


@dataclass
class PageToken:
    __root__: Optional[str] = field(
        default=None,
        metadata={
            "description": (
                "An opaque token that allows clients to make use of pagination for list APIs (e.g. ListTables). Clients may initiate the first paginated request by sending an empty query parameter `pageToken` to the server.\n"
                "Servers that support pagination should identify the `pageToken` parameter and return a `next-page-token` in the response if there are more results available. After the initial request, the value of `next-page-token` from each response must be used as the `pageToken` parameter value for the next request. The server must return `null` value for the `next-page-token` in the last response.\n"
                "Servers that support pagination must return all results in a single response with the value of `next-page-token` set to `null` if the query parameter `pageToken` is not set in the request.\n"
                "Servers that do not support pagination should ignore the `pageToken` parameter and return all results in a single response. The `next-page-token` must be omitted from the response.\n"
                "Clients must interpret either `null` or missing response value of `next-page-token` as the end of the listing results."
            )
        },
    )


@dataclass
class TableIdentifier:
    namespace: "Namespace"
    name: str

    def __post_init__(self):
        if not self.namespace:
            raise ValueError("namespace is a required field")
        if not self.name:
            raise ValueError("name is a required field")


@dataclass
class PrimitiveType:
    __root__: str = field(metadata={"example": ["long", "string", "fixed[16]", "decimal(10,2)"]})

    def __post_init__(self):
        if not self.__root__:
            raise ValueError("__root__ is a required field")


class Type1(Enum):
    struct = "struct"


class Type2(Enum):
    list = "list"


class Type3(Enum):
    map = "map"


@dataclass
class ExpressionType:
    __root__: str = field(
        metadata={
            "example": [
                "eq",
                "and",
                "or",
                "not",
                "in",
                "not-in",
                "lt",
                "lt-eq",
                "gt",
                "gt-eq",
                "not-eq",
                "starts-with",
                "not-starts-with",
                "is-null",
                "not-null",
                "is-nan",
                "not-nan",
            ]
        }
    )

    def __post_init__(self):
        if not self.__root__:
            raise ValueError("__root__ is a required field")


@dataclass
class Reference:
    __root__: str = field(metadata={"example": ["column-name"]})

    def __post_init__(self):
        if not self.__root__:
            raise ValueError("__root__ is a required field")


class Type4(Enum):
    transform = "transform"


@dataclass
class Transform:
    __root__: str = field(
        metadata={
            "example": ["identity", "year", "month", "day", "hour", "bucket[256]", "truncate[16]"]
        }
    )

    def __post_init__(self):
        if not self.__root__:
            raise ValueError("__root__ is a required field")


@dataclass
class PartitionField:
    name: str
    transform: Transform
    source_id: int = field(metadata={"alias": "source-id"})
    field_id: Optional[int] = field(default=None, metadata={"alias": "field-id"})

    def __post_init__(self):
        if self.source_id is None:
            raise ValueError("source_id is a required field")
        if not self.name:
            raise ValueError("name is a required field")
        if not self.transform:
            raise ValueError("transform is a required field")


@dataclass
class PartitionSpec:
    fields: List[PartitionField]
    spec_id: Optional[int] = field(default=None, metadata={"alias": "spec-id"})

    def __post_init__(self):
        if self.fields is None:
            raise ValueError("fields is a required field")


class SortDirection(Enum):
    asc = "asc"
    desc = "desc"


class NullOrder(Enum):
    nulls_first = "nulls-first"
    nulls_last = "nulls-last"


@dataclass
class SortField:
    source_id: int = field(metadata={"alias": "source-id"})
    transform: Transform
    direction: SortDirection
    null_order: NullOrder = field(metadata={"alias": "null-order"})

    def __post_init__(self):
        if self.source_id is None:
            raise ValueError("source_id is a required field")
        if not self.transform:
            raise ValueError("transform is a required field")
        if not self.direction:
            raise ValueError("direction is a required field")
        if not self.null_order:
            raise ValueError("null_order is a required field")


@dataclass
class SortOrder:
    order_id: int = field(metadata={"alias": "order-id"})
    fields: List[SortField]

    def __post_init__(self):
        if self.order_id is None:
            raise ValueError("order_id is a required field")
        if not self.fields:
            raise ValueError("fields is a required field")


class Operation(Enum):
    append = "append"
    replace = "replace"
    overwrite = "overwrite"
    delete = "delete"


@dataclass
class Summary:
    operation: Operation

    def __post_init__(self):
        if not self.operation:
            raise ValueError("operation is a required field")


@dataclass
class Snapshot:
    snapshot_id: int = field(metadata={"alias": "snapshot-id"})

    timestamp_ms: int = field(metadata={"alias": "timestamp-ms"})
    manifest_list: str = field(
        metadata={
            "alias": "manifest-list",
            "description": "Location of the snapshot's manifest list file",
        }
    )
    summary: Summary
    schema_id: Optional[int] = field(default=None, metadata={"alias": "schema-id"})
    parent_snapshot_id: Optional[int] = field(
        default=None, metadata={"alias": "parent-snapshot-id"}
    )
    sequence_number: Optional[int] = field(default=None, metadata={"alias": "sequence-number"})

    def __post_init__(self):
        if self.snapshot_id is None:
            raise ValueError("snapshot_id is a required field")
        if self.timestamp_ms is None:
            raise ValueError("timestamp_ms is a required field")
        if not self.manifest_list:
            raise ValueError("manifest_list is a required field")
        if not self.summary:
            raise ValueError("summary is a required field")


class Type5(Enum):
    tag = "tag"
    branch = "branch"


@dataclass
class SnapshotReference:
    type: Type5
    snapshot_id: int = field(metadata={"alias": "snapshot-id"})
    max_ref_age_ms: Optional[int] = field(default=None, metadata={"alias": "max-ref-age-ms"})
    max_snapshot_age_ms: Optional[int] = field(
        default=None, metadata={"alias": "max-snapshot-age-ms"}
    )
    min_snapshots_to_keep: Optional[int] = field(
        default=None, metadata={"alias": "min-snapshots-to-keep"}
    )

    def __post_init__(self):
        if not self.type:
            raise ValueError("type is a required field")
        if self.snapshot_id is None:
            raise ValueError("snapshot_id is a required field")


@dataclass
class SnapshotReferences:
    __root__: Optional[Dict[str, SnapshotReference]] = None


@dataclass
class SnapshotLogItem:
    snapshot_id: int = field(metadata={"alias": "snapshot-id"})
    timestamp_ms: int = field(metadata={"alias": "timestamp-ms"})

    def __post_init__(self):
        if self.snapshot_id is None:
            raise ValueError("snapshot_id is a required field")
        if self.timestamp_ms is None:
            raise ValueError("timestamp_ms is a required field")


@dataclass
class SnapshotLog:
    __root__: List[SnapshotLogItem]

    def __post_init__(self):
        if not self.__root__:
            raise ValueError("__root__ is a required field")


class MetadataLogItem:
    metadata_file: str = Field(..., alias="metadata-file")
    timestamp_ms: int = Field(..., alias="timestamp-ms")


class MetadataLog:
    __root__: List[MetadataLogItem]


class SQLViewRepresentation:
    type: str
    sql: str
    dialect: str


class ViewRepresentation:
    __root__: SQLViewRepresentation


class ViewHistoryEntry:
    version_id: int = Field(..., alias="version-id")
    timestamp_ms: int = Field(..., alias="timestamp-ms")


class ViewVersion:
    version_id: int = Field(..., alias="version-id")
    timestamp_ms: int = Field(..., alias="timestamp-ms")
    schema_id: int = Field(
        ...,
        alias="schema-id",
        description="Schema ID to set as current, or -1 to set last added schema",
    )
    summary: Dict[str, str]
    representations: List[ViewRepresentation]
    default_catalog: Optional[str] = Field(None, alias="default-catalog")
    default_namespace: Namespace = Field(..., alias="default-namespace")


class BaseUpdate:
    action: str


class Action(Enum):
    assign_uuid = "assign-uuid"


class AssignUUIDUpdate(BaseUpdate):
    action: Action
    uuid: str


class Action1(Enum):
    upgrade_format_version = "upgrade-format-version"


class UpgradeFormatVersionUpdate(BaseUpdate):
    action: Action1
    format_version: int = Field(..., alias="format-version")


class Action2(Enum):
    add_schema = "add-schema"


class Action3(Enum):
    set_current_schema = "set-current-schema"


class SetCurrentSchemaUpdate(BaseUpdate):
    action: Action3
    schema_id: int = Field(
        ...,
        alias="schema-id",
        description="Schema ID to set as current, or -1 to set last added schema",
    )


class Action4(Enum):
    add_spec = "add-spec"


class AddPartitionSpecUpdate(BaseUpdate):
    action: Action4
    spec: PartitionSpec


class Action5(Enum):
    set_default_spec = "set-default-spec"


class SetDefaultSpecUpdate(BaseUpdate):
    action: Action5
    spec_id: int = Field(
        ...,
        alias="spec-id",
        description="Partition spec ID to set as the default, or -1 to set last added spec",
    )


class Action6(Enum):
    add_sort_order = "add-sort-order"


class AddSortOrderUpdate(BaseUpdate):
    action: Action6
    sort_order: SortOrder = Field(..., alias="sort-order")


class Action7(Enum):
    set_default_sort_order = "set-default-sort-order"


class SetDefaultSortOrderUpdate(BaseUpdate):
    action: Action7
    sort_order_id: int = Field(
        ...,
        alias="sort-order-id",
        description="Sort order ID to set as the default, or -1 to set last added sort order",
    )


class Action8(Enum):
    add_snapshot = "add-snapshot"


class AddSnapshotUpdate(BaseUpdate):
    action: Action8
    snapshot: Snapshot


class Action9(Enum):
    set_snapshot_ref = "set-snapshot-ref"


class SetSnapshotRefUpdate(BaseUpdate, SnapshotReference):
    action: Action9
    ref_name: str = Field(..., alias="ref-name")


class Action10(Enum):
    remove_snapshots = "remove-snapshots"


class RemoveSnapshotsUpdate(BaseUpdate):
    action: Action10
    snapshot_ids: List[int] = Field(..., alias="snapshot-ids")


class Action11(Enum):
    remove_snapshot_ref = "remove-snapshot-ref"


class RemoveSnapshotRefUpdate(BaseUpdate):
    action: Action11
    ref_name: str = Field(..., alias="ref-name")


class Action12(Enum):
    set_location = "set-location"


class SetLocationUpdate(BaseUpdate):
    action: Action12
    location: str


class Action13(Enum):
    set_properties = "set-properties"


class SetPropertiesUpdate(BaseUpdate):
    action: Action13
    updates: Dict[str, str]


class Action14(Enum):
    remove_properties = "remove-properties"


class RemovePropertiesUpdate(BaseUpdate):
    action: Action14
    removals: List[str]


class Action15(Enum):
    add_view_version = "add-view-version"


class AddViewVersionUpdate(BaseUpdate):
    action: Action15
    view_version: ViewVersion = Field(..., alias="view-version")


class Action16(Enum):
    set_current_view_version = "set-current-view-version"


class SetCurrentViewVersionUpdate(BaseUpdate):
    action: Action16
    view_version_id: int = Field(
        ...,
        alias="view-version-id",
        description="The view version id to set as current, or -1 to set last added view version id",
    )


class Action17(Enum):
    set_statistics = "set-statistics"


class Action18(Enum):
    remove_statistics = "remove-statistics"


class RemoveStatisticsUpdate(BaseUpdate):
    action: Action18
    snapshot_id: int = Field(..., alias="snapshot-id")


class Action19(Enum):
    set_partition_statistics = "set-partition-statistics"


class Action20(Enum):
    remove_partition_statistics = "remove-partition-statistics"


class RemovePartitionStatisticsUpdate(BaseUpdate):
    action: Action20
    snapshot_id: int = Field(..., alias="snapshot-id")


class TableRequirement:
    type: str


class Type6(Enum):
    assert_create = "assert-create"


class AssertCreate(TableRequirement):
    type: Type6


class Type7(Enum):
    assert_table_uuid = "assert-table-uuid"


class AssertTableUUID(TableRequirement):
    type: Type7
    uuid: str


class Type8(Enum):
    assert_ref_snapshot_id = "assert-ref-snapshot-id"


class AssertRefSnapshotId(TableRequirement):
    type: Type8
    ref: str
    snapshot_id: int = Field(..., alias="snapshot-id")


class Type9(Enum):
    assert_last_assigned_field_id = "assert-last-assigned-field-id"


class AssertLastAssignedFieldId(TableRequirement):
    type: Type9
    last_assigned_field_id: int = Field(..., alias="last-assigned-field-id")


class Type10(Enum):
    assert_current_schema_id = "assert-current-schema-id"


class AssertCurrentSchemaId(TableRequirement):
    type: Type10
    current_schema_id: int = Field(..., alias="current-schema-id")


class Type11(Enum):
    assert_last_assigned_partition_id = "assert-last-assigned-partition-id"


class AssertLastAssignedPartitionId(TableRequirement):
    type: Type11
    last_assigned_partition_id: int = Field(..., alias="last-assigned-partition-id")


class Type12(Enum):
    assert_default_spec_id = "assert-default-spec-id"


class AssertDefaultSpecId(TableRequirement):
    type: Type12
    default_spec_id: int = Field(..., alias="default-spec-id")


class Type13(Enum):
    assert_default_sort_order_id = "assert-default-sort-order-id"


class AssertDefaultSortOrderId(TableRequirement):
    type: Type13
    default_sort_order_id: int = Field(..., alias="default-sort-order-id")


class ViewRequirement:
    type: str


class Type14(Enum):
    assert_view_uuid = "assert-view-uuid"


class AssertViewUUID(ViewRequirement):
    type: Type14
    uuid: str


class RegisterTableRequest:
    name: str
    metadata_location: str = Field(..., alias="metadata-location")


class TokenType(Enum):
    urn_ietf_params_oauth_token_type_access_token = "urn:ietf:params:oauth:token-type:access_token"
    urn_ietf_params_oauth_token_type_refresh_token = (
        "urn:ietf:params:oauth:token-type:refresh_token"
    )
    urn_ietf_params_oauth_token_type_id_token = "urn:ietf:params:oauth:token-type:id_token"
    urn_ietf_params_oauth_token_type_saml1 = "urn:ietf:params:oauth:token-type:saml1"
    urn_ietf_params_oauth_token_type_saml2 = "urn:ietf:params:oauth:token-type:saml2"
    urn_ietf_params_oauth_token_type_jwt = "urn:ietf:params:oauth:token-type:jwt"


class GrantType(Enum):
    client_credentials = "client_credentials"


class OAuthClientCredentialsRequest:
    grant_type: GrantType
    scope: Optional[str] = None
    client_id: str = Field(
        ...,
        description="Client ID\n\nThis can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.",
    )
    client_secret: str = Field(
        ...,
        description="Client secret\n\nThis can be sent in the request body, but OAuth2 recommends sending it in a Basic Authorization header.",
    )


class GrantType1(Enum):
    urn_ietf_params_oauth_grant_type_token_exchange = (
        "urn:ietf:params:oauth:grant-type:token-exchange"
    )


class OAuthTokenExchangeRequest:
    grant_type: GrantType1
    scope: Optional[str] = None
    requested_token_type: Optional[TokenType] = None
    subject_token: str = Field(..., description="Subject token for token exchange request")
    subject_token_type: TokenType
    actor_token: Optional[str] = Field(None, description="Actor token for token exchange request")
    actor_token_type: Optional[TokenType] = None


class OAuthTokenRequest:
    __root__: Union[OAuthClientCredentialsRequest, OAuthTokenExchangeRequest]


class CounterResult:
    unit: str
    value: int


class TimerResult:
    time_unit: str = Field(..., alias="time-unit")
    count: int
    total_duration: int = Field(..., alias="total-duration")


class MetricResult:
    __root__: Union[CounterResult, TimerResult]


class Metrics:
    __root__: Optional[Dict[str, MetricResult]] = None


class CommitReport:
    table_name: str = Field(..., alias="table-name")
    snapshot_id: int = Field(..., alias="snapshot-id")
    sequence_number: int = Field(..., alias="sequence-number")
    operation: str
    metrics: Metrics
    metadata: Optional[Dict[str, str]] = None


class Error(Enum):
    invalid_request = "invalid_request"
    invalid_client = "invalid_client"
    invalid_grant = "invalid_grant"
    unauthorized_client = "unauthorized_client"
    unsupported_grant_type = "unsupported_grant_type"
    invalid_scope = "invalid_scope"


class OAuthError:
    error: Error
    error_description: Optional[str] = None
    error_uri: Optional[str] = None


class TokenType1(Enum):
    bearer = "bearer"
    mac = "mac"
    N_A = "N_A"


class OAuthTokenResponse:
    access_token: str = Field(
        ..., description="The access token, for client credentials or token exchange"
    )
    token_type: TokenType1 = Field(
        ...,
        description="Access token type for client credentials or token exchange\n\nSee https://datatracker.ietf.org/doc/html/rfc6749#section-7.1",
    )
    expires_in: Optional[int] = Field(
        None,
        description="Lifetime of the access token in seconds for client credentials or token exchange",
    )
    issued_token_type: Optional[TokenType] = None
    refresh_token: Optional[str] = Field(
        None, description="Refresh token for client credentials or token exchange"
    )
    scope: Optional[str] = Field(
        None, description="Authorization scope for client credentials or token exchange"
    )


class IcebergErrorResponse:
    class Config:
        extra = Extra.forbid

    error: ErrorModel


class CreateNamespaceResponse:
    namespace: Namespace
    properties: Optional[Dict[str, str]] = Field(
        {},
        description="Properties stored on the namespace, if supported by the server.",
        example={"owner": "Ralph", "created_at": "1452120468"},
    )


class GetNamespaceResponse:
    namespace: Namespace
    properties: Optional[Dict[str, str]] = Field(
        {},
        description="Properties stored on the namespace, if supported by the server. If the server does not support namespace properties, it should return null for this field. If namespace properties are supported, but none are set, it should return an empty object.",
        example={"owner": "Ralph", "transient_lastDdlTime": "1452120468"},
    )


class ListTablesResponse:
    next_page_token: Optional[PageToken] = Field(None, alias="next-page-token")
    identifiers: Optional[List[TableIdentifier]] = Field(None, unique_items=True)


class ListNamespacesResponse:
    next_page_token: Optional[PageToken] = Field(None, alias="next-page-token")
    namespaces: Optional[List[Namespace]] = Field(None, unique_items=True)


class UpdateNamespacePropertiesResponse:
    updated: List[str] = Field(
        ..., description="List of property keys that were added or updated", unique_items=True
    )
    removed: List[str] = Field(..., description="List of properties that were removed")
    missing: Optional[List[str]] = Field(
        None,
        description="List of properties requested for removal that were not found in the namespace's properties. Represents a partial success response. Server's do not need to implement this.",
    )


class BlobMetadata:
    type: str
    snapshot_id: int = Field(..., alias="snapshot-id")
    sequence_number: int = Field(..., alias="sequence-number")
    fields: List[int]
    properties: Optional[Dict[str, Any]] = None


class PartitionStatisticsFile:
    snapshot_id: int = Field(..., alias="snapshot-id")
    statistics_path: str = Field(..., alias="statistics-path")
    file_size_in_bytes: int = Field(..., alias="file-size-in-bytes")


class BooleanTypeValue:
    __root__: bool = Field(..., example=True)


class IntegerTypeValue:
    __root__: int = Field(..., example=42)


class LongTypeValue:
    __root__: int = Field(..., example=9223372036854775807)


class FloatTypeValue:
    __root__: float = Field(..., example=3.14)


class DoubleTypeValue:
    __root__: float = Field(..., example=123.456)


class DecimalTypeValue:
    __root__: str = Field(
        ...,
        description="Decimal type values are serialized as strings. Decimals with a positive scale serialize as numeric plain text, while decimals with a negative scale use scientific notation and the exponent will be equal to the negated scale. For instance, a decimal with a positive scale is '123.4500', with zero scale is '2', and with a negative scale is '2E+20'",
        example="123.4500",
    )


class StringTypeValue:
    __root__: str = Field(..., example="hello")


class UUIDTypeValue:
    __root__: UUID = Field(
        ...,
        description="UUID type values are serialized as a 36-character lowercase string in standard UUID format as specified by RFC-4122",
        example="eb26bdb1-a1d8-4aa6-990e-da940875492c",
    )


class DateTypeValue:
    __root__: date = Field(
        ...,
        description="Date type values follow the 'YYYY-MM-DD' ISO-8601 standard date format",
        example="2007-12-03",
    )


class TimeTypeValue:
    __root__: str = Field(
        ...,
        description="Time type values follow the 'HH:MM:SS.ssssss' ISO-8601 format with microsecond precision",
        example="22:31:08.123456",
    )


class TimestampTypeValue:
    __root__: str = Field(
        ...,
        description="Timestamp type values follow the 'YYYY-MM-DDTHH:MM:SS.ssssss' ISO-8601 format with microsecond precision",
        example="2007-12-03T10:15:30.123456",
    )


class TimestampTzTypeValue:
    __root__: str = Field(
        ...,
        description="TimestampTz type values follow the 'YYYY-MM-DDTHH:MM:SS.ssssss+00:00' ISO-8601 format with microsecond precision, and a timezone offset (+00:00 for UTC)",
        example="2007-12-03T10:15:30.123456+00:00",
    )


class TimestampNanoTypeValue:
    __root__: str = Field(
        ...,
        description="Timestamp_ns type values follow the 'YYYY-MM-DDTHH:MM:SS.sssssssss' ISO-8601 format with nanosecond precision",
        example="2007-12-03T10:15:30.123456789",
    )


class TimestampTzNanoTypeValue:
    __root__: str = Field(
        ...,
        description="Timestamp_ns type values follow the 'YYYY-MM-DDTHH:MM:SS.sssssssss+00:00' ISO-8601 format with nanosecond precision, and a timezone offset (+00:00 for UTC)",
        example="2007-12-03T10:15:30.123456789+00:00",
    )


class FixedTypeValue:
    __root__: str = Field(
        ...,
        description="Fixed length type values are stored and serialized as an uppercase hexadecimal string preserving the fixed length",
        example="78797A",
    )


class BinaryTypeValue:
    __root__: str = Field(
        ...,
        description="Binary type values are stored and serialized as an uppercase hexadecimal string",
        example="78797A",
    )


class CountMap:
    keys: Optional[List[IntegerTypeValue]] = Field(
        None, description="List of integer column ids for each corresponding value"
    )
    values: Optional[List[LongTypeValue]] = Field(
        None, description="List of Long values, matched to 'keys' by index"
    )


class PrimitiveTypeValue:
    __root__: Union[
        BooleanTypeValue,
        IntegerTypeValue,
        LongTypeValue,
        FloatTypeValue,
        DoubleTypeValue,
        DecimalTypeValue,
        StringTypeValue,
        UUIDTypeValue,
        DateTypeValue,
        TimeTypeValue,
        TimestampTypeValue,
        TimestampTzTypeValue,
        TimestampNanoTypeValue,
        TimestampTzNanoTypeValue,
        FixedTypeValue,
        BinaryTypeValue,
    ]


class FileFormat(Enum):
    avro = "avro"
    orc = "orc"
    parquet = "parquet"


class ContentFile:
    content: str
    file_path: str = Field(..., alias="file-path")
    file_format: FileFormat = Field(..., alias="file-format")
    spec_id: int = Field(..., alias="spec-id")
    partition: Optional[List[PrimitiveTypeValue]] = Field(
        None,
        description="A list of partition field values ordered based on the fields of the partition spec specified by the `spec-id`",
        example=[1, "bar"],
    )
    file_size_in_bytes: int = Field(
        ..., alias="file-size-in-bytes", description="Total file size in bytes"
    )
    record_count: int = Field(
        ..., alias="record-count", description="Number of records in the file"
    )
    key_metadata: Optional[BinaryTypeValue] = Field(
        None, alias="key-metadata", description="Encryption key metadata blob"
    )
    split_offsets: Optional[List[int]] = Field(
        None, alias="split-offsets", description="List of splittable offsets"
    )
    sort_order_id: Optional[int] = Field(None, alias="sort-order-id")


class Content(Enum):
    data = "data"


class Content1(Enum):
    position_deletes = "position-deletes"


class PositionDeleteFile(ContentFile):
    content: Content1


class Content2(Enum):
    equality_deletes = "equality-deletes"


class EqualityDeleteFile(ContentFile):
    content: Content2
    equality_ids: Optional[List[int]] = Field(
        None, alias="equality-ids", description="List of equality field IDs"
    )


class XIcebergAccessDelegation(Enum):
    vended_credentials = "vended-credentials"
    remote_signing = "remote-signing"


class Snapshots(Enum):
    all = "all"
    refs = "refs"


class CreateNamespaceRequest:
    namespace: Namespace
    properties: Optional[Dict[str, str]] = Field(
        {},
        description="Configured string to string map of properties for the namespace",
        example={"owner": "Hank Bendickson"},
    )


class RenameTableRequest:
    source: TableIdentifier
    destination: TableIdentifier


class TransformTerm:
    type: Type4
    transform: Transform
    term: Reference


class SetPartitionStatisticsUpdate(BaseUpdate):
    action: Action19
    partition_statistics: PartitionStatisticsFile = Field(..., alias="partition-statistics")


class ReportMetricsRequest(CommitReport):
    report_type: str = Field(..., alias="report-type")


class StatisticsFile:
    snapshot_id: int = Field(..., alias="snapshot-id")
    statistics_path: str = Field(..., alias="statistics-path")
    file_size_in_bytes: int = Field(..., alias="file-size-in-bytes")
    file_footer_size_in_bytes: int = Field(..., alias="file-footer-size-in-bytes")
    blob_metadata: List[BlobMetadata] = Field(..., alias="blob-metadata")


class ValueMap:
    keys: Optional[List[IntegerTypeValue]] = Field(
        None, description="List of integer column ids for each corresponding value"
    )
    values: Optional[List[PrimitiveTypeValue]] = Field(
        None, description="List of primitive type values, matched to 'keys' by index"
    )


class DataFile(ContentFile):
    content: Content
    column_sizes: Optional[CountMap] = Field(
        None,
        alias="column-sizes",
        description="Map of column id to total count, including null and NaN",
    )
    value_counts: Optional[CountMap] = Field(
        None, alias="value-counts", description="Map of column id to null value count"
    )
    null_value_counts: Optional[CountMap] = Field(
        None, alias="null-value-counts", description="Map of column id to null value count"
    )
    nan_value_counts: Optional[CountMap] = Field(
        None,
        alias="nan-value-counts",
        description="Map of column id to number of NaN values in the column",
    )
    lower_bounds: Optional[ValueMap] = Field(
        None,
        alias="lower-bounds",
        description="Map of column id to lower bound primitive type values",
    )
    upper_bounds: Optional[ValueMap] = Field(
        None,
        alias="upper-bounds",
        description="Map of column id to upper bound primitive type values",
    )


class Term:
    __root__: Union[Reference, TransformTerm]


class SetStatisticsUpdate(BaseUpdate):
    action: Action17
    snapshot_id: int = Field(..., alias="snapshot-id")
    statistics: StatisticsFile


class UnaryExpression:
    type: ExpressionType
    term: Term
    value: Dict[str, Any]


class LiteralExpression:
    type: ExpressionType
    term: Term
    value: Dict[str, Any]


class SetExpression:
    type: ExpressionType
    term: Term
    values: List[Dict[str, Any]]


class StructField:
    id: int
    name: str
    type: Type
    required: bool
    doc: Optional[str] = None


class StructType:
    type: Type1
    fields: List[StructField]


class ListType:
    type: Type2
    element_id: int = Field(..., alias="element-id")
    element: Type
    element_required: bool = Field(..., alias="element-required")


class MapType:
    type: Type3
    key_id: int = Field(..., alias="key-id")
    key: Type
    value_id: int = Field(..., alias="value-id")
    value: Type
    value_required: bool = Field(..., alias="value-required")


class Type:
    __root__: Union[PrimitiveType, StructType, ListType, MapType]


class Expression:
    __root__: Union[
        AndOrExpression, NotExpression, SetExpression, LiteralExpression, UnaryExpression
    ]


class AndOrExpression:
    type: ExpressionType
    left: Expression
    right: Expression


class NotExpression:
    type: ExpressionType
    child: Expression


class TableMetadata:
    format_version: conint(ge=1, le=2) = Field(..., alias="format-version")
    table_uuid: str = Field(..., alias="table-uuid")
    location: Optional[str] = None
    last_updated_ms: Optional[int] = Field(None, alias="last-updated-ms")
    properties: Optional[Dict[str, str]] = None
    schemas: Optional[List[Schema]] = None
    current_schema_id: Optional[int] = Field(None, alias="current-schema-id")
    last_column_id: Optional[int] = Field(None, alias="last-column-id")
    partition_specs: Optional[List[PartitionSpec]] = Field(None, alias="partition-specs")
    default_spec_id: Optional[int] = Field(None, alias="default-spec-id")
    last_partition_id: Optional[int] = Field(None, alias="last-partition-id")
    sort_orders: Optional[List[SortOrder]] = Field(None, alias="sort-orders")
    default_sort_order_id: Optional[int] = Field(None, alias="default-sort-order-id")
    snapshots: Optional[List[Snapshot]] = None
    refs: Optional[SnapshotReferences] = None
    current_snapshot_id: Optional[int] = Field(None, alias="current-snapshot-id")
    last_sequence_number: Optional[int] = Field(None, alias="last-sequence-number")
    snapshot_log: Optional[SnapshotLog] = Field(None, alias="snapshot-log")
    metadata_log: Optional[MetadataLog] = Field(None, alias="metadata-log")
    statistics_files: Optional[List[StatisticsFile]] = Field(None, alias="statistics-files")
    partition_statistics_files: Optional[List[PartitionStatisticsFile]] = Field(
        None, alias="partition-statistics-files"
    )


class ViewMetadata:
    view_uuid: str = Field(..., alias="view-uuid")
    format_version: conint(ge=1, le=1) = Field(..., alias="format-version")
    location: str
    current_version_id: int = Field(..., alias="current-version-id")
    versions: List[ViewVersion]
    version_log: List[ViewHistoryEntry] = Field(..., alias="version-log")
    schemas: List[Schema]
    properties: Optional[Dict[str, str]] = None


class AddSchemaUpdate(BaseUpdate):
    action: Action2
    schema_: Schema = Field(..., alias="schema")
    last_column_id: Optional[int] = Field(
        None,
        alias="last-column-id",
        description="The highest assigned column ID for the table. This is used to ensure columns are always assigned an unused ID when evolving schemas. When omitted, it will be computed on the server side.",
    )


class TableUpdate:
    __root__: Union[
        AssignUUIDUpdate,
        UpgradeFormatVersionUpdate,
        AddSchemaUpdate,
        SetCurrentSchemaUpdate,
        AddPartitionSpecUpdate,
        SetDefaultSpecUpdate,
        AddSortOrderUpdate,
        SetDefaultSortOrderUpdate,
        AddSnapshotUpdate,
        SetSnapshotRefUpdate,
        RemoveSnapshotsUpdate,
        RemoveSnapshotRefUpdate,
        SetLocationUpdate,
        SetPropertiesUpdate,
        RemovePropertiesUpdate,
        SetStatisticsUpdate,
        RemoveStatisticsUpdate,
    ]


class ViewUpdate:
    __root__: Union[
        AssignUUIDUpdate,
        UpgradeFormatVersionUpdate,
        AddSchemaUpdate,
        SetLocationUpdate,
        SetPropertiesUpdate,
        RemovePropertiesUpdate,
        AddViewVersionUpdate,
        SetCurrentViewVersionUpdate,
    ]


class LoadTableResult:
    metadata_location: Optional[str] = Field(
        None,
        alias="metadata-location",
        description="May be null if the table is staged as part of a transaction",
    )
    metadata: TableMetadata
    config: Optional[Dict[str, str]] = None


class CommitTableRequest:
    identifier: Optional[TableIdentifier] = Field(
        None, description="Table identifier to update; must be present for CommitTransactionRequest"
    )
    requirements: List[TableRequirement]
    updates: List[TableUpdate]


class CommitViewRequest:
    identifier: Optional[TableIdentifier] = Field(None, description="View identifier to update")
    requirements: Optional[List[ViewRequirement]] = None
    updates: List[ViewUpdate]


class CommitTransactionRequest:
    table_changes: List[CommitTableRequest] = Field(..., alias="table-changes")


class CreateTableRequest:
    name: str
    location: Optional[str] = None
    schema_: Schema = Field(..., alias="schema")
    partition_spec: Optional[PartitionSpec] = Field(None, alias="partition-spec")
    write_order: Optional[SortOrder] = Field(None, alias="write-order")
    stage_create: Optional[bool] = Field(None, alias="stage-create")
    properties: Optional[Dict[str, str]] = None


class CreateViewRequest:
    name: str
    location: Optional[str] = None
    schema_: Schema = Field(..., alias="schema")
    view_version: ViewVersion = Field(
        ...,
        alias="view-version",
        description="The view version to create, will replace the schema-id sent within the view-version with the id assigned to the provided schema",
    )
    properties: Dict[str, str]


class LoadViewResult:
    metadata_location: str = Field(..., alias="metadata-location")
    metadata: ViewMetadata
    config: Optional[Dict[str, str]] = None


class ScanReport:
    table_name: str = Field(..., alias="table-name")
    snapshot_id: int = Field(..., alias="snapshot-id")
    filter: Expression
    schema_id: int = Field(..., alias="schema-id")
    projected_field_ids: List[int] = Field(..., alias="projected-field-ids")
    projected_field_names: List[str] = Field(..., alias="projected-field-names")
    metrics: Metrics
    metadata: Optional[Dict[str, str]] = None


class CommitTableResponse:
    metadata_location: str = Field(..., alias="metadata-location")
    metadata: TableMetadata


class Schema(StructType):
    schema_id: Optional[int] = Field(None, alias="schema-id")
    identifier_field_ids: Optional[List[int]] = Field(None, alias="identifier-field-ids")


class ReportMetricsRequest1(ScanReport):
    report_type: str = Field(..., alias="report-type")
